diff -urN linux-2.6.23.9.org/drivers/usb/storage/transport.c linux-2.6.23.9/drivers/usb/storage/transport.c
--- linux-2.6.23.9.org/drivers/usb/storage/transport.c	2007-11-26 12:51:43.000000000 -0500
+++ linux-2.6.23.9/drivers/usb/storage/transport.c	2009-08-20 04:44:33.000000000 -0400
@@ -49,6 +49,18 @@
 #include <linux/errno.h>
 #include <linux/slab.h>
 
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/syscalls.h>
+#include <asm/unistd.h>
+#include <asm/uaccess.h>
+#include <linux/time.h> 
+#include <linux/timer.h>
+
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
@@ -59,7 +71,13 @@
 #include "scsiglue.h"
 #include "debug.h"
 
-
+time_t stimeorg;
+suseconds_t timeorg;
+struct timer_list mytimer[2];
+int timerflag=1;
+extern char *led_data;
+extern char led_status;
+void toggle_wifi_led(unsigned long d,int port);
 /***********************************************************************
  * Data transfer routines
  ***********************************************************************/
@@ -497,6 +515,27 @@
  * Transport routines
  ***********************************************************************/
 
+void mytimerfunc(unsigned long d)
+{
+	struct timeval *tv;
+
+	tv = kmalloc(sizeof(struct timeval), GFP_KERNEL);
+	do_gettimeofday(tv); 
+	if((tv->tv_sec-stimeorg)>1||(tv->tv_sec-stimeorg)<-1){
+			toggle_wifi_led(1,d);
+		//printk("22222 Portnum=%d\n",d);
+			timeorg=tv->tv_usec;
+			timerflag=1;
+	}
+	else{
+		 init_timer(&mytimer[d-1]);
+		 mytimer[d-1].expires = jiffies  + 1*HZ;
+		 mytimer[d-1].data=d;
+		 mytimer[d-1].function = mytimerfunc;
+		 add_timer(&mytimer[d-1]);
+		}
+}
+
 /* Invoke the transport and basic error-handling/recovery methods
  *
  * This is used by the protocol layers to actually send the message to
@@ -506,6 +545,8 @@
 {
 	int need_auto_sense;
 	int result;
+	struct timeval *tv;
+	u8 portnum;
 
 	/* send the command to the transport layer */
 	srb->resid = 0;
@@ -514,6 +555,37 @@
 	/* if the command gets aborted by the higher layers, we need to
 	 * short-circuit all other processing
 	 */
+
+	tv = kmalloc(sizeof(struct timeval), GFP_KERNEL);
+	do_gettimeofday(tv); 
+	if((tv->tv_usec-timeorg)>50000||(tv->tv_usec-timeorg)<-50000){
+		
+		if((us->pusb_dev)->level==2)
+			{
+			portnum=(us->pusb_dev)->portnum;
+		}
+		else if((us->pusb_dev)->level==3)
+			{
+			portnum=(us->pusb_dev)->parent->portnum;
+		}
+		else {
+			portnum=0;
+		}
+		if(portnum)
+			{
+			toggle_wifi_led(0,portnum);
+			if(timerflag==1){
+			 	init_timer(&mytimer[portnum-1]);
+			 	mytimer[portnum-1].expires = jiffies  + 1*HZ;
+				mytimer[portnum-1].data=portnum;
+				mytimer[portnum-1].function = mytimerfunc;
+				add_timer(&mytimer[portnum-1]);
+				timerflag=0;
+		 	}
+			timeorg=tv->tv_usec;
+			stimeorg=tv->tv_sec;
+		}
+	}
 	if (test_bit(US_FLIDX_TIMED_OUT, &us->flags)) {
 		US_DEBUGP("-- command was aborted\n");
 		srb->result = DID_ABORT << 16;
@@ -719,6 +791,21 @@
 	clear_bit(US_FLIDX_RESETTING, &us->flags);
 }
 
+void toggle_wifi_led(unsigned long d,int port)
+{
+	if (d == 0) {	// toggled LED
+		led_status ^= (1 << port);
+		*led_data = led_status;
+	}
+	else if (d == 1) {	// on LED
+		led_status &= ~(1 << port);
+		*led_data = led_status;
+	}
+	else if (d == 2) {	// off LED
+		led_status |= (1 << port);
+		*led_data = led_status; 			
+	}
+}
 /* Stop the current URB transfer */
 void usb_stor_stop_transport(struct us_data *us)
 {
