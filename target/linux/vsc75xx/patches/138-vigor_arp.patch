--- linux-2.6.23.17/net/ipv4/arp.c-orig	2011-08-10 11:17:21.000000000 +0800
+++ linux-2.6.23.17/net/ipv4/arp.c	2011-10-12 18:47:16.000000000 +0800
@@ -659,6 +659,243 @@
 }
 
 /*
+ *	Create an Vigor arp packet. Modified from DrayOS 2009 by James.Lin, 20110608 
+ */
+ 
+#if 1 // auto-detection function
+static unsigned short vigor_client_id=0; // static global variable for client id
+int vigor_wan_type;
+int vigor_wan_get_ip;
+char vigor_device_name_old[32] = {0};
+char vigor_device_name_new[32] = {0};
+char vigor_device_name_null[32] = {0};
+
+struct sk_buff * init_client_arp(int type, int ptype, __be32 dest_ip,
+			   struct net_device *dev, __be32 src_ip,
+			   unsigned char *dest_hw, unsigned char *src_hw,
+			   unsigned char *target_hw, unsigned char vigoropcode)
+{
+	struct sk_buff *skb;
+	struct vigor_arphdr *vigor_arp;
+	unsigned char *vigor_arp_ptr;
+	struct in_device *in_dev;  // to get dev's IP address
+	struct in_ifaddr *ifa = NULL;	// to get dev's IP address
+	
+
+	/*
+	 *	Allocate a buffer
+	 */
+
+	skb = alloc_skb(sizeof(struct vigor_arphdr)+ 2*(dev->addr_len+4)
+				+ LL_RESERVED_SPACE(dev ), GFP_ATOMIC);
+
+	if (skb == NULL)
+		return NULL;
+
+	skb_reserve(skb, LL_RESERVED_SPACE(dev));
+	skb_reset_network_header(skb);
+	vigor_arp = (struct vigor_arphdr *) skb_put(skb,sizeof(struct vigor_arphdr)/* + 2*(dev->addr_len+4)*/);
+	vigor_arp_ptr = (unsigned char *)vigor_arp;
+	skb->dev = dev;
+	skb->protocol = htons(ETH_P_ARP);
+
+	if (src_hw == NULL)
+		src_hw = dev->dev_addr;
+	if (dest_hw == NULL)
+		dest_hw = dev->broadcast;
+
+	/*
+	 *	Fill the device header for the ARP frame
+	 */
+	if (dev->hard_header &&
+	    dev->hard_header(skb,dev,ptype,dest_hw,src_hw,skb->len) < 0)
+		goto out;
+
+	/*
+	 * Fill out the arp protocol part.
+	 *
+	 * The arp hardware type should match the device type, except for FDDI,
+	 * which (according to RFC 1390) should always equal 1 (Ethernet).
+	 */
+	/*
+	 *	Exceptions everywhere. AX.25 uses the AX.25 PID value not the
+	 *	DIX code for the protocol. Make these device structure fields.
+	 */
+	switch (dev->type) {
+	default:
+		vigor_arp->ar_hrd = htons(dev->type);
+		vigor_arp->ar_pro = htons(ETH_P_IP);
+		break;
+
+#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
+	case ARPHRD_AX25:
+		vigor_arp->ar_hrd = htons(ARPHRD_AX25);
+		vigor_arp->ar_pro = htons(AX25_P_IP);
+		break;
+
+#if defined(CONFIG_NETROM) || defined(CONFIG_NETROM_MODULE)
+	case ARPHRD_NETROM:
+		vigor_arp->ar_hrd = htons(ARPHRD_NETROM);
+		vigor_arp->ar_pro = htons(AX25_P_IP);
+		break;
+#endif
+#endif
+
+#ifdef CONFIG_FDDI
+	case ARPHRD_FDDI:
+		vigor_arp->ar_hrd = htons(ARPHRD_ETHER);
+		vigor_arp->ar_pro = htons(ETH_P_IP);
+		break;
+#endif
+#ifdef CONFIG_TR
+	case ARPHRD_IEEE802_TR:
+		vigor_arp->ar_hrd = htons(ARPHRD_IEEE802);
+		vigor_arp->ar_pro = htons(ETH_P_IP);
+		break;
+#endif
+	}
+
+	vigor_arp->ar_hln = dev->addr_len;
+	vigor_arp->ar_pln = 4;
+	vigor_arp->ar_op = htons(type);
+
+	vigor_arp_ptr+=8;
+	
+
+	//printk("source MAC: %2x-%2x-%2x-%2x-%2x-%2x\n", src_hw[0], src_hw[1], src_hw[2], src_hw[3], src_hw[4], src_hw[5]);
+	memcpy(vigor_arp_ptr, src_hw, dev->addr_len);
+	vigor_arp_ptr+=dev->addr_len;
+
+	if ((vigor_wan_type == KEEP_ALIVE_DHCP) && (vigor_wan_get_ip != KEEP_ALIVE_GOT_IP))	// to get dev's IP address
+		memset(vigor_arp_ptr, 0, 4);
+	else if ((in_dev=__in_dev_get_rtnl(dev)) != NULL) { 
+		ifa = in_dev->ifa_list;
+		//printk("source IP: %d\n", ipaddr);
+		if (ifa != NULL)
+			memcpy(vigor_arp_ptr, &ifa->ifa_local, 4);
+		else
+			memset(vigor_arp_ptr, 0, 4);
+			//memcpy(vigor_arp_ptr, &src_ip,4);
+	} else
+		memset(vigor_arp_ptr, 0, 4);
+	
+	vigor_arp_ptr+=4;
+	if (target_hw != NULL)
+		memcpy(vigor_arp_ptr, target_hw, dev->addr_len);
+	else
+		memset(vigor_arp_ptr, 0, dev->addr_len);
+	vigor_arp_ptr+=dev->addr_len;
+	memcpy(vigor_arp_ptr, &dest_ip, 4);
+	vigor_arp_ptr+=4;
+
+	memset(vigor_arp_ptr, 0, 68);
+
+	//printk("Client ID is %d\n", vigor_client_id);
+
+	switch (vigoropcode){
+        case VIG_BC_MSG:
+            if (vigor_client_id != 0){
+				if (strcmp(vigor_device_name_old, vigor_device_name_new) == 0){
+					prepare_client_arp_packet(vigor_arp_ptr, KEEP_ALIVE, REPLY_PKT, vigor_client_id);
+				}
+				else{
+					vigor_client_id = 0;
+					memset(vigor_device_name_old, 0, sizeof(vigor_device_name_old));
+					strcpy(vigor_device_name_old, vigor_device_name_new);
+					prepare_client_arp_packet(vigor_arp_ptr, DEV_ACK, REPLY_PKT, vigor_client_id);
+				}
+            }
+            else
+                prepare_client_arp_packet(vigor_arp_ptr, DEV_ACK, REPLY_PKT, vigor_client_id);   //trigger client to send DHCP request
+            break;
+        case TRI_DHCP_REQ:
+			strcpy(vigor_device_name_old, vigor_device_name_new);
+            prepare_client_arp_packet(vigor_arp_ptr, DEV_MOD_NAME, REPLY_PKT, vigor_client_id);   //trigger client to send DHCP request
+            break;
+        case VIG_RST_CLIENT:
+            vigor_client_id = 0;
+            prepare_client_arp_packet(vigor_arp_ptr, DEV_ACK, REPLY_PKT, vigor_client_id);
+            break;
+    }
+    
+
+return skb;	
+
+out:
+	kfree_skb(skb);
+	return NULL;
+}
+
+/*
+ *	Create an Vigor arp packet. Modified from DrayOS 2009 by James.Lin, 20110608 
+ */
+void prepare_client_arp_packet(unsigned char *vigor_arp_hdr, char opcode, int pkt_type, unsigned short  id)
+{
+    //data
+	*vigor_arp_hdr = opcode;
+	vigor_arp_hdr += 1;   	
+	if (opcode == DEV_MOD_NAME)
+		*vigor_arp_hdr = 6 + strlen(MODEL_NAME) + strlen(vigor_device_name_old);
+	else
+		*vigor_arp_hdr = 0;
+	vigor_arp_hdr += 1;
+	memcpy(vigor_arp_hdr, &id,2);
+	vigor_arp_hdr += 2;
+	
+	if (opcode == DEV_MOD_NAME){
+		*vigor_arp_hdr = Draytek_PartnerID;
+		vigor_arp_hdr += 4;
+		strcpy(vigor_arp_hdr, MODEL_NAME);
+		vigor_arp_hdr += strlen(MODEL_NAME);
+		strcpy(vigor_arp_hdr, ", ");
+		vigor_arp_hdr += 2;
+		strcpy(vigor_arp_hdr, vigor_device_name_old);
+	}else if (opcode == KEEP_ALIVE){
+       	*vigor_arp_hdr = Draytek_PartnerID;
+		vigor_arp_hdr += 4;
+		
+       	if ((vigor_wan_type == KEEP_ALIVE_DHCP) && (vigor_wan_get_ip == KEEP_ALIVE_GOT_IP))
+		 	memset(vigor_arp_hdr, KEEP_ALIVE_DHCP_GOT_IP , 1);			
+		else if ((vigor_wan_type == KEEP_ALIVE_DHCP) && (vigor_wan_get_ip == KEEP_ALIVE_GET_FAIL))
+			memset(vigor_arp_hdr, KEEP_ALIVE_DHCP_GET_FAIL, 1);
+		else if (vigor_wan_type == KEEP_ALIVE_STATIC)
+			memset(vigor_arp_hdr, KEEP_ALIVE_STATIC_IP, 1);
+	}else if (opcode == DEV_ACK){
+        *vigor_arp_hdr = 0;
+    }
+}
+
+
+/*
+ *	Create and send an Vigor ARP packet.
+ */
+
+void vigor_arp_send(int type, int ptype, __be32 dest_ip,
+	      struct net_device *dev, __be32 src_ip,
+	      unsigned char *dest_hw, unsigned char *src_hw,
+	      unsigned char *target_hw, unsigned char vigorop)
+{
+	struct sk_buff *skb;
+
+	/*
+	 *	No arp on this interface.
+	 */
+
+	if (dev->flags&IFF_NOARP)
+		return;
+
+	skb = init_client_arp(type, ptype, dest_ip, dev, src_ip,
+			 	dest_hw, src_hw, target_hw, vigorop);
+		
+	if (skb == NULL) {
+		return;
+	}
+
+	arp_xmit(skb);
+}
+#endif
+
+/*
  *	Send an arp packet.
  */
 void arp_xmit(struct sk_buff *skb)
@@ -705,10 +942,12 @@
 	unsigned char *arp_ptr;
 	struct rtable *rt;
 	unsigned char *sha, *tha;
+	unsigned char *arp_start;
 	__be32 sip, tip;
 	u16 dev_type = dev->type;
 	int addr_type;
 	struct neighbour *n;
+	unsigned char vigor_op;
 
 	/* arp_rcv below verifies the ARP header and verifies the device
 	 * is ARP'able.
@@ -717,7 +956,7 @@
 	if (in_dev == NULL)
 		goto out;
 
-	arp = arp_hdr(skb);
+	arp = arp_start = arp_hdr(skb);
 
 	switch (dev_type) {
 	default:
@@ -758,7 +997,8 @@
 	/* Understand only these message types */
 
 	if (arp->ar_op != htons(ARPOP_REPLY) &&
-	    arp->ar_op != htons(ARPOP_REQUEST))
+	    arp->ar_op != htons(ARPOP_REQUEST) && 
+	    arp->ar_op != htons(ARPOP_FROM_VIGOR) )  // If ARP is sent from Vigor router, don't drop it.
 		goto out;
 
 /*
@@ -811,6 +1051,18 @@
 		goto out;
 	}
 
+	/* Process ARP packet which is a Vigor ARP packet */
+	#if 1 // auto-detection function
+	if (arp->ar_op == htons(ARPOP_FROM_VIGOR) && ((vigor_wan_type == KEEP_ALIVE_DHCP)||(vigor_wan_type == KEEP_ALIVE_STATIC)||(strcmp(dev->name,"br-lan") == 0))
+		&& (memcmp(vigor_device_name_null, vigor_device_name_new, sizeof(vigor_device_name_new)) != 0)){
+		vigor_op = *(arp_start + 28);
+		if (vigor_client_id == 0)
+			vigor_client_id = *((unsigned short *)(arp_start + 30)); 
+		vigor_arp_send(ARPOP_TO_VIGOR,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha, vigor_op);
+		goto out;
+	}
+	#endif
+
 	if (arp->ar_op == htons(ARPOP_REQUEST) &&
 	    ip_route_input(skb, tip, sip, 0, dev) == 0) {
 
--- linux-2.6.23.17/include/net/arp.h-orig	2011-08-10 11:19:21.000000000 +0800
+++ linux-2.6.23.17/include/net/arp.h	2011-10-11 16:20:13.000000000 +0800
@@ -6,6 +6,7 @@
 #include <net/neighbour.h>
 
 #define HAVE_ARP_CREATE
+#define MODEL_NAME "Vigor-2130"
 
 extern struct neigh_table arp_tbl;
 
@@ -15,6 +16,19 @@
 extern void     arp_send(int type, int ptype, __be32 dest_ip,
 			 struct net_device *dev, __be32 src_ip,
 			 unsigned char *dest_hw, unsigned char *src_hw, unsigned char *th);
+
+#if 1 // auto-detection
+/* Function prototype for Vigor ARP packets */
+extern void	vigor_arp_send(int type, int ptype, __be32 dest_ip,
+	      		struct net_device *dev, __be32 src_ip,
+	      		unsigned char *dest_hw, unsigned char *src_hw,
+	      		unsigned char *th, unsigned char vigorop);
+extern struct sk_buff * init_client_arp(int type, int ptype, __be32 dest_ip,
+			   struct net_device *dev, __be32 src_ip,
+			   unsigned char *dest_hw, unsigned char *src_hw,
+			   unsigned char *target_hw, unsigned char vigoropcode);
+extern void prepare_client_arp_packet(unsigned char *vigor_arp_hdr, char opcode, int pkt_type, unsigned short  id);
+#endif
 extern int	arp_bind_neighbour(struct dst_entry *dst);
 extern int	arp_mc_map(__be32 addr, u8 *haddr, struct net_device *dev, int dir);
 extern void	arp_ifdown(struct net_device *dev);
--- linux-2.6.23.17/include/linux/if_arp.h-orig	2011-08-10 11:19:30.000000000 +0800
+++ linux-2.6.23.17/include/linux/if_arp.h	2011-10-12 10:10:04.000000000 +0800
@@ -97,7 +97,35 @@
 #define	ARPOP_InREQUEST	8		/* InARP request		*/
 #define	ARPOP_InREPLY	9		/* InARP reply			*/
 #define	ARPOP_NAK	10		/* (ATM)ARP NAK			*/
+#define   ARPOP_FROM_VIGOR  0x0200		/* Vigor Router ARP request		*/ 
+#define   ARPOP_TO_VIGOR  	0x0201		/* Vigor Switch ARP Reply		*/
 
+//vigor opcode
+//router -> switch
+#define VIG_BC_MSG           001    /* vigor router broadcast message */
+#define TRI_DHCP_REQ         002    /* vigor router trigger client to send dhcp request packet */
+#define VIG_RST_CLIENT       003    /* vigor trigger client to reset message */
+//switch -> router
+#define DEV_ACK              101    /* device ack message */
+#define DEV_MOD_NAME         102    /* device model name */
+#define KEEP_ALIVE           103    /* keep a alive message */
+
+//packet type
+#define REQUEST_PKT          1      /*Vigor router send arp request pkt to client */
+#define REPLY_PKT            2      /*Vigor router send arp reply pkt to client */
+#define Draytek_PartnerID    3      /* Draytek Linux Kernel router*/
+
+//keep alive type
+#define KEEP_ALIVE_DHCP_GOT_IP          0      /*Vigor clinet wan dhcp get IP*/
+#define KEEP_ALIVE_DHCP_GETTING_IP      1      /*Vigor clinet wan dhcp not yet get IP*/
+#define KEEP_ALIVE_DHCP_GET_FAIL        2      /*Vigor clinet wan dhcp get IP fail*/
+#define KEEP_ALIVE_STATIC_IP          	3      /*Vigor clinet wan static IP*/
+
+//keep alive WAN type and status
+#define KEEP_ALIVE_DHCP			1		/*Vigor clinet wan type dhcp*/
+#define KEEP_ALIVE_STATIC		2		/*Vigor clinet wan type static*/
+#define KEEP_ALIVE_GOT_IP		1		/*Vigor clinet dhcp get IP*/
+#define KEEP_ALIVE_GET_FAIL		2		/*Vigor clinet dhcp get IP fail*/ 
 
 /* ARP ioctl request. */
 struct arpreq {
@@ -148,9 +176,33 @@
 
 };
 
+struct vigor_arphdr
+{
+	__be16		ar_hrd;		/* format of hardware address	*/
+	__be16		ar_pro;		/* format of protocol address	*/
+	unsigned char	ar_hln;		/* length of hardware address	*/
+	unsigned char	ar_pln;		/* length of protocol address	*/
+	__be16		ar_op;		/* ARP opcode (command)		*/
+
+	 /*
+	  *	 Ethernet looks like this : This bit is variable sized however...
+	  */
+	unsigned char		ar_sha[ETH_ALEN];	/* sender hardware address	*/
+	unsigned char		ar_sip[4];		/* sender IP address		*/
+	unsigned char		ar_tha[ETH_ALEN];	/* target hardware address	*/
+	unsigned char		ar_tip[4];		/* target IP address		*/
+	unsigned char   	vigoropcode;
+	unsigned char   	datalen;
+	unsigned short  	id;
+	unsigned char   	partner_id;
+	unsigned char   	reserved[3];
+	unsigned char   	data[60];
+};
+
 #ifdef __KERNEL__
 #include <linux/skbuff.h>
 
+
 static inline struct arphdr *arp_hdr(const struct sk_buff *skb)
 {
 	return (struct arphdr *)skb_network_header(skb);
